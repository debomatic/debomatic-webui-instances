{
  "name": "tailfd",
  "description": "Tail a file. This will continue to work even if a file is unlinked rotated or truncated. It is also ok if the path doesnt exist before watching it",
  "version": "0.1.6",
  "author": {
    "name": "Ryan Day",
    "email": "soldair@gmail.com"
  },
  "keywords": [
    "watch",
    "tail",
    "descriptors",
    "log",
    "fs"
  ],
  "main": "./tail.js",
  "homepage": "http://github.com/soldair/node-tailfd",
  "repository": {
    "type": "git",
    "url": "git://github.com/soldair/node-tailfd.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "devDependencies": {
    "tap": "*",
    "jshint": "0.5.x"
  },
  "engines": {
    "node": ">=0.6.0"
  },
  "dependencies": {
    "watchfd": "~0.0.12"
  },
  "license": "MIT/X11",
  "readme": "[![Build Status](https://secure.travis-ci.org/soldair/node-tailfd.png)](http://travis-ci.org/soldair/node-tailfd)\n \n## tailfd\n\nTails a file. it should work great. it will continue to work even if a file is unlinked rotated or truncated. It is also ok if the path doesnt exist before watching it\n\n## Example\n\n```js\n\nvar tail = require('tailfd').tail,\nwatcher = tail('/some.log',function(line,tailInfo){\n  //default line listener. optional.\n  console.log('line of data> ',line);\n});\n\n```\n\nwhen you are done\n\n```js\nwatcher.close();\n\n```\n\n## install\n\n\tnpm install tailfd\n\n### argument structure\n\ntailfd.tail(filename, [options], listener)\n\n- filename\n  - this should be a regular file or non existent. the behavior is undefined in the case of a directory.\n\n- options. supported custom options are\n\n\t```js\n\t{\n\n\t\"start\":undefined, //defaults to the first reported stat.size\n\t//optional. a hard start position in the file for tail to start emitting data events.\n\n\t\"offset\":0,\n\t//optional.  offset is negtively applied to the start position\n\n\t\"delimiter\":\"\\n\",\n\t//optional. defaults to newline but can be anything\n\n\t\"maxBytesPerRead\":10240,\n\t// optional. this is how much data will be read off of a file descriptor in one call to fs.read. defaults to 10k.\n\t// the maximum data buffer size for each tail is \n\t// \tmaxBufferPerRead + the last incomplete line from the previous read.length\n\n\t\"readAttempts\":3,\n\t//optional. if fs.read cannot read the offset from a file it will try attempts times before is gives up with a range-unreadable event\n\t// defaults to 3 attempts\n\n\t\"maxLineLength\":102400\n\t// optional. defaults to 1 mb\n\t//  if the line excedes this length it's data will be emitted as a line-part event\n        //  this is a failsafe so that a single line cant eat all of the memory.\n\t//  all gathered line-parts are complete with the value of the next line event for that file descriptor.\n\n\t}\n\n\t// the options object is passed to watchfd as well. With watchfd you may configure\n\n\t{\n\n\t\"timeout\": 60*60*1000, //defaults to one hour\n\t//how long an inactive file descriptor can remain inactive before being cleared\n\n\t\"timeoutInterval\":60*5*1000 //every five minutes\n\t// how often to check for inactive file descriptors\n\n\t}\n\n\t//the options object is also passed directly to fs.watch and fs.watchFile so you may configure\n\n\t{\n\t\"persistent\":true, //defaults to true\n\t//persistent indicates whether the process should continue to run as long as files are being watched\n\n\t\"interval\":0, //defaults 0\n\t//interval indicates how often the target should be polled, in milliseconds. (On Linux systems with inotify, interval is ignored.) \n\t}\n\n\t```\n\n- callback\n  - this is bound to the line event of the watcher. its optional.\n\n\t```js\n\tcallback(line,tailInfo)\n\n\t```\n\n  cur and prev are instances of fs.Stats\n\n- @returns\n  TailFD Watcher\n\nWatcher.pause\n- pause data and line events on all underlying descriptors\n\nWatcher.resume\n- get it goin again! =)\n\n\n### events\n\n- line\n\t- String line, Object tailInfo\n- data\n\t- Buffer buffer, Object tailInfo\n- line-part\n\t- String linePart, Object tailInfo\n\t\t- if line length excedes the options.maxLineLength the linePart is emitted. \n\t\t  This is to prevent cases where unexpected values in logs can eat all of the memory.\n- range-unreadable\n\t- Array errors, Number fromPos,Number toPos,Object tailInfo\n\t\t- After configured readAttempts the offset could still not be read. This range will be skipped\n\n### events inherited from watchfd\n\n- change\n\t- fs.Stats cur, fs.Stats prev\n- open\n\t- fs.Stats cur,{fd:file descriptor,stat:fs.Stats cur}\n- unlink\n\t- fs.Stats cur,{fd:file descriptor,stat:fs.Stats cur}\n- timeout\n\t- fs.Stats cur,{fd:file descriptor,stat:fs.Stats cur}\n\n### tailInfo properties\n\n- stat\n\t- instanceof fs.Stats\n- pos\n\t- current seek position in the file\n- fd\n\t- file descriptor being tailed\n- buf\n\t- string containing the last data fragment from delimiter parsing\n\n\n#### watch file and watch may behave differently on different systems here is the doc for it.\n\n- http://nodejs.org/api/fs.html#fs_fs_writefile_filename_data_encoding_callback\n- http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/soldair/node-tailfd/issues"
  },
  "_id": "tailfd@0.1.6",
  "_from": "tailfd@*"
}
